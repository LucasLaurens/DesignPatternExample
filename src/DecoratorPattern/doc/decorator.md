# Decorator Pattern

## Type

This design pattern is of the : Structural.

## How does it work, basically ?

*More information from* [Refactoring Guru](https://refactoring.guru/fr/design-patterns/decorator)

### Problem

Imagine you're using a library in which a user model is available. However, in your application you need to have users with anonymous emails, so as not to transmit certain information. However, the basic library doesn't allow you to do this. In addition, the latter is based on the assumption that classes cannot be upgraded by library users, and so classes are determined as final.

### Resolution

The first thing that comes to mind when we want to modify the behavior of an object is to extend its class. However, here are a few warnings about inheritance:

- Inheritance is static. You cannot modify an object's behavior at runtime. You can only replace the entire object with another, generated by a different subclass.
- Subclasses can only have one parent. In most programming languages, you can only inherit from one class at a time.

The decorator has the target attribute you need (reference), in this case "User", and can then reuse its methods and arrange them to suit your needs. In other words, if in our case we want to have anonymous information, we can retrieve the basic information and transform it into a decorator method.

This decorator could just as easily transform different user classes as long as they have the desired interface in the decorator.
